# 二分查找算法模板及例题

- ACwing模板

```C++
int check(vector<int>& nums, int target){
	int left = 0, right = nums.size();
    while (right > left){
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else if (nums[mid] > target) right = mid;
        else return mid;
    }
    return -1;
}

//float version 
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
```

- 适用范围：

1. 线性容器，且容器当中的元素有序，如果无序则需要先排序（快排、……）

2. 注意容易错的点：

   (1)循环不变量：主要是要明确自己已经搜索过哪些空间了

   ```C++
   //左闭右闭
   int left = 0;
   int right = nums.size() - 1;
   while (left <= right){
       int mid = left + (right - left) / 2;
       if (nums[mid] < target) left = mid + 1;
       else right = mid - 1;
   }
   return left;
   //左闭右开：
   int left = 0;
   int right = nums.size();
   while (right > left){
       int mid = left + (right - left) / 2;
       if (nums[mid] < target) left = mid + 1;
       else right = mid;
   }
   return left;//or return right
   //因为此时左右都是指向target的
   ```

    (2)关于不同的判断方式可以认为有这样的公式：>x 等价于>=x + 1对于整数

   ------

   ## 例题+ 参考解（C++）

- [35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

  ```C++
  class Solution {
  public:
      int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1;
        while (right >= left){
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) left = mid + 1;
          else right = mid - 1;
        }
        return left;
      }
  };
  ```

  

- [34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

  ```C++
  class Solution {
      // lower_bound 返回最小的满足 nums[i] >= target 的 i
      // 如果数组为空，或者所有数都 < target，则返回 nums.size()
      // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
  
      // 闭区间写法
      int lower_bound(vector<int> &nums, int target) {
          int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
          while (left <= right) { // 区间不为空
              // 循环不变量：
              // nums[left-1] < target
              // nums[right+1] >= target
              int mid = left + (right - left) / 2;
              if (nums[mid] < target) {
                  left = mid + 1; // 范围缩小到 [mid+1, right]
              } else {
                  right = mid - 1; // 范围缩小到 [left, mid-1]
              }
          }
          return left;
      }
  
      // 左闭右开区间写法
      int lower_bound2(vector<int> &nums, int target) {
          int left = 0, right = nums.size(); // 左闭右开区间 [left, right)
          while (left < right) { // 区间不为空
              // 循环不变量：
              // nums[left-1] < target
              // nums[right] >= target
              int mid = left + (right - left) / 2;
              if (nums[mid] < target) {
                  left = mid + 1; // 范围缩小到 [mid+1, right)
              } else {
                  right = mid; // 范围缩小到 [left, mid)
              }
          }
          return left; // 返回 left 还是 right 都行，因为循环结束后 left == right
      }
  
      // 开区间写法
      int lower_bound3(vector<int> &nums, int target) {
          int left = -1, right = nums.size(); // 开区间 (left, right)
          while (left + 1 < right) { // 区间不为空
              // 循环不变量：
              // nums[left] < target
              // nums[right] >= target
              int mid = left + (right - left) / 2;
              if (nums[mid] < target) {
                  left = mid; // 范围缩小到 (mid, right)
              } else {
                  right = mid; // 范围缩小到 (left, mid)
              }
              // 也可以这样写
              // (nums[mid] < target ? left : right) = mid;
          }
          return right;
      }
  
  public:
      vector<int> searchRange(vector<int> &nums, int target) {
          int start = lower_bound(nums, target); // 使用其中一种写法即可
          if (start == nums.size() || nums[start] != target) {
              return {-1, -1}; // nums 中没有 target
          }
          // 如果 start 存在，那么 end 必定存在
          int end = lower_bound(nums, target + 1) - 1;
          return {start, end};
      }
  };
  
  ```

  

- [69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/description/)

  ```C++
  class Solution {
  public:
      int mySqrt(int x) {
          int left = 0, right = x;
          int ans = -1;
          while (left <= right){
              int mid = left + (right - left) / 2;
              if ((long long) mid * mid <= x){
                  ans = mid;
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }
          return ans;
      }
  };
  ```

  

- [744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/)

  ```C++
  class Solution {
  public:
      char nextGreatestLetter(vector<char>& letters, char target) {
          int left = 0, right = letters.size();
          while (left < right){
              int mid = left + (right - left) / 2;
              if (letters[mid] > target) right = mid;
              else left = mid + 1;
          }
          if (left == letters.size()) return letters[0];
          return letters[left];
      }
  };
  ```

  
