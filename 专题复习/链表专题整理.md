# 链表专题整理：

## 链表数据结构定义：ACM使用

```C++
struct ListNode*{
    int val;
    ListNode* next;
    ListNode(int _val) : val(_val), next(nullptr) {}
    ListNode(int _val, ListNode* _next) : val(_val), next(_next) {}
};
```
```C++
#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int _val) : val(_val), next(nullptr) {}
}

int _size = 0;
ListNode* dummyHead = new ListNode(0);

int get(int index){
    if (index < 0 || index > (_size - 1)) return -1;
    ListNode* cur = dummyHead->next;
    while (index--){
        cur = cur->next;
    }
    return cur->val;
}

void addAtHead(int val){
    ListNode* newNode = new ListNode(val);
    newNode->next = dummyHead->next;
    dummyHead->next = newNode;
    _size++;
}

void addAtTail(int val){
    ListNode* newNode = new ListNode(val);
    ListNode* cur = dummyHead;
    while (cur->next){
        cur = cur->next;
    }
    cur->next = newNode;
    _size++;
}

int addAtIndex(int val, int index){
    if (index < 0) return -1;
    if (index > _size) return -1;
    
    ListNode* newNode = new ListNode(val);
    ListNode* cur = dummyHead;
    while (index--){
        cur = cur->next;
    }
    newNode->next = cur->next;
    cur->next = newNode;
    _size++;
    return 0;
}

int deleteAtIndex(int index){
    if (index > _size || index < 0){
        return -1;
    }
    ListNode* cur = dummyHead;
    while (index--){
        cur = cur->next;
    }
    ListNode* tmp = cur->next;
    cur->next = cur->next->next;
    
    delete tmp;
    tmp = nullptr;
    _size--;
    return 0;
}

int printLinkList(){
    ListNode* cur = dummyHead;
    if (cur->next == nullptr) return -1;
    while (cur->next) {
        cout << cur->next->val << " ";
        cur = cur->next;
    }
    cout << endl;
    return 0;
}

int main(){
    int n, a, m, t, z;
    string s;
    cin >> n;
    ListNode* head = nullptr;
    while (n--){
        cin >> a;
        addAtHead(a);
    }
    cin >> m;
    while (m--){
        cin >> s;
        if (s == "show"){
            if (printLinkList() == -1) cout<< "Link list is empty" << endl;
        }
        if (s == "delete"){
            cin >> t;
            if (deleteAtIndex(t - 1) == -1) cout << "delete fail" << endl;
            else cout << "delete OK" << endl;
        }
        if (s == "insert"){
            cin >> t >> z;
            if (addAtIndex(z, t - 1) == -1) cout << "insert fail" << endl;
            else cout << "insert OK" << endl;
        }
        if (s == "get"){
            cin >> t;
            int getValue = get(t - 1);
            if (getValue == -1) cout << "get fail" << endl;
            else cout << getValue << endl;
        }
    }
}
```

- [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

## 链表基础操作一览：

- 反转链表：后一个结点指向前一个，保存cur->next，返回prev

- 遍历链表：cur = cur->next，访问时index - 1 or dummyHead

- 链表相交判断：快慢指针判断，while条件注意fast->next

- 删除链表结点：cur = cur->next

- 环形链表判断：快慢指针+入口判断（相遇节点和头结点开始找）

- 寻找中间节点（倒数结点）：快慢指针return slow

- 合并两个链表：临时结点保存节点的next

- 两两交换链表结点：

  ```C++
  while (cur->next && cur->next->next) {
              ListNode* tmp = cur->next;
              ListNode* tmp1 = cur->next->next->next;
  
              cur->next = cur->next->next;
              cur->next->next = tmp;
              cur->next->next->next = tmp1;
  
              cur = cur->next->next;
          }
  ```

  

<img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1" style="zoom:33%;" />

## 进阶相关问题：

- [2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)
- [25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked)
- [146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&envId=top-100-liked)

- [25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-100-liked)
- [138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)
